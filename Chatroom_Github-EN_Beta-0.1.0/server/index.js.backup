const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');
const os = require('os');
const crypto = require('crypto');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  maxHttpBufferSize: 100 * 1024 * 1024
});

const PORT = process.env.PORT || 3000;

// ===== æ•°æ®å­˜å‚¨è·¯å¾„ =====
const dataDir = path.join(__dirname, '../data');
const uploadsDir = path.join(__dirname, '../uploads');
const avatarsDir = path.join(uploadsDir, 'avatars');
const filesDir = path.join(uploadsDir, 'files');
const voicesDir = path.join(uploadsDir, 'voices');
const imagesDir = path.join(uploadsDir, 'images');
const videosDir = path.join(uploadsDir, 'videos');

// åˆ›å»ºæ‰€æœ‰å¿…è¦çš„ç›®å½•
[dataDir, uploadsDir, avatarsDir, filesDir, voicesDir, imagesDir, videosDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// ===== æ•°æ®æ–‡ä»¶è·¯å¾„ =====
const usersFile = path.join(dataDir, 'users.json');
const messagesFile = path.join(dataDir, 'messages.json');
const roomsFile = path.join(dataDir, 'rooms.json');

// ===== æ•°æ®å­˜å‚¨å·¥å…·å‡½æ•° =====
function loadJSON(filePath, defaultValue = {}) {
  try {
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(data);
    }
  } catch (e) {
    console.error(`åŠ è½½ ${filePath} å¤±è´¥:`, e);
  }
  return defaultValue;
}

function saveJSON(filePath, data) {
  try {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
  } catch (e) {
    console.error(`ä¿å­˜ ${filePath} å¤±è´¥:`, e);
  }
}

// ===== åŠ è½½æŒä¹…åŒ–æ•°æ® =====
let registeredUsers = loadJSON(usersFile, {}); // { odp: userInfo }
let allMessages = loadJSON(messagesFile, {}); // { chatKey: messages[] }
let allRooms = loadJSON(roomsFile, {}); // { roomId: roomInfo }

// ===== è¿è¡Œæ—¶æ•°æ® =====
const onlineSockets = new Map(); // socketId -> odp
const userSockets = new Map(); // odp -> socketId

// ===== å¯†ç å“ˆå¸Œ =====
function hashPassword(password) {
  return crypto.createHash('sha256').update(password).digest('hex');
}

// ===== è·å–èŠå¤©ID =====
function getChatId(odp1, odp2) {
  return [odp1, odp2].sort().join('_');
}

// ===== è·å–æœ¬æœºIP =====
function getLocalIP() {
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) {
        return iface.address;
      }
    }
  }
  return 'localhost';
}

// ===== é…ç½®æ–‡ä»¶ä¸Šä¼  =====
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let dest = filesDir;
    if (file.mimetype.startsWith('image/')) dest = imagesDir;
    else if (file.mimetype.startsWith('video/')) dest = videosDir;
    else if (file.mimetype.startsWith('audio/')) dest = voicesDir;
    cb(null, dest);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const uniqueName = `${Date.now()}-${uuidv4()}${ext}`;
    cb(null, uniqueName);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 100 * 1024 * 1024 }
});

// ===== Expressä¸­é—´ä»¶ =====
app.use(express.static(path.join(__dirname, '../public')));
app.use('/uploads', express.static(uploadsDir));
app.use(express.json());

// ===== æ–‡ä»¶ä¸Šä¼ æ¥å£ =====
app.post('/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'æ²¡æœ‰æ–‡ä»¶ä¸Šä¼ ' });
  }
  
  const folder = path.basename(path.dirname(req.file.path));
  const fileUrl = `/uploads/${folder}/${req.file.filename}`;
  res.json({
    url: fileUrl,
    filename: req.file.originalname,
    mimetype: req.file.mimetype,
    size: req.file.size
  });
});

// å¤´åƒä¸Šä¼ 
app.post('/upload/avatar', upload.single('avatar'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'æ²¡æœ‰æ–‡ä»¶ä¸Šä¼ ' });
  }
  
  const newPath = path.join(avatarsDir, req.file.filename);
  if (req.file.path !== newPath) {
    fs.renameSync(req.file.path, newPath);
  }
  
  res.json({
    url: `/uploads/avatars/${req.file.filename}`
  });
});

// ===== Socket.IO è¿æ¥å¤„ç† =====
io.on('connection', (socket) => {
  console.log(`[è¿æ¥] ${socket.id}`);

  // ===== ä¼šè¯æ¢å¤ =====
  socket.on('session:restore', (data) => {
    const { odp, username } = data;
    
    if (!odp || !registeredUsers[odp]) {
      console.log(`[ä¼šè¯æ¢å¤] å¤±è´¥ - ç”¨æˆ·ä¸å­˜åœ¨: ${username}`);
      return socket.emit('session:fail');
    }
    
    const user = registeredUsers[odp];
    
    // æ£€æŸ¥æ˜¯å¦å·²åœ¨çº¿ï¼ˆè¸¢æ‰æ—§è¿æ¥ï¼‰
    if (userSockets.has(odp)) {
      const oldSocketId = userSockets.get(odp);
      if (oldSocketId !== socket.id) {
        const oldSocket = io.sockets.sockets.get(oldSocketId);
        if (oldSocket) {
          oldSocket.emit('force:logout', { message: 'æ‚¨çš„è´¦å·åœ¨å…¶ä»–è®¾å¤‡ç™»å½•' });
          oldSocket.disconnect();
        }
      }
    }
    
    // è®°å½•åœ¨çº¿çŠ¶æ€
    onlineSockets.set(socket.id, odp);
    userSockets.set(odp, socket.id);
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·æ­¤ç”¨æˆ·ä¸Šçº¿
    socket.broadcast.emit('user:online', {
      odp: user.odp,
      nickname: user.nickname,
      avatar: user.avatar,
      signature: user.signature
    });
    
    console.log(`[ä¼šè¯æ¢å¤] ${user.nickname} (${username})`);
    
    socket.emit('session:restored', { 
      user: {
        odp: user.odp,
        username: user.username,
        nickname: user.nickname,
        avatar: user.avatar,
        signature: user.signature
      }
    });
    
    // å‘é€åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆæ’é™¤è‡ªå·±ï¼‰
    sendOnlineUsers(socket, user.odp);
    
    // å‘é€ç¾¤èŠåˆ—è¡¨
    sendUserRooms(socket, user.odp);
  });

  // ===== ç”¨æˆ·æ³¨å†Œ =====
  socket.on('user:register', (data) => {
    const { username, password, nickname, avatar, signature } = data;
    
    // éªŒè¯
    if (!username || !password) {
      return socket.emit('register:fail', { message: 'ç”¨æˆ·åå’Œå¯†ç ä¸èƒ½ä¸ºç©º' });
    }
    
    if (username.length < 3 || username.length > 20) {
      return socket.emit('register:fail', { message: 'ç”¨æˆ·åé•¿åº¦éœ€è¦3-20ä¸ªå­—ç¬¦' });
    }
    
    // ç”¨æˆ·åæ ¼å¼éªŒè¯
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      return socket.emit('register:fail', { message: 'ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿' });
    }
    
    if (password.length < 6) {
      return socket.emit('register:fail', { message: 'å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦' });
    }
    
    // å¯†ç å¼ºåº¦éªŒè¯
    if (!/[a-zA-Z]/.test(password)) {
      return socket.emit('register:fail', { message: 'å¯†ç éœ€è¦åŒ…å«è‡³å°‘ä¸€ä¸ªå­—æ¯' });
    }
    
    if (!/[0-9]/.test(password)) {
      return socket.emit('register:fail', { message: 'å¯†ç éœ€è¦åŒ…å«è‡³å°‘ä¸€ä¸ªæ•°å­—' });
    }
    
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    const existingUser = Object.values(registeredUsers).find(u => u.username === username);
    if (existingUser) {
      return socket.emit('register:fail', { message: 'ç”¨æˆ·åå·²è¢«æ³¨å†Œ' });
    }
    
    // åˆ›å»ºç”¨æˆ·
    const odp = uuidv4();
    const user = {
      odp,
      username,
      password: hashPassword(password),
      nickname: nickname || username,
      avatar: avatar || null,
      signature: signature || '',
      createdAt: new Date().toISOString(),
      friends: [],
      groups: []
    };
    
    registeredUsers[odp] = user;
    saveJSON(usersFile, registeredUsers);
    
    // è®°å½•åœ¨çº¿çŠ¶æ€
    onlineSockets.set(socket.id, user.odp);
    userSockets.set(user.odp, socket.id);
    
    console.log(`[æ³¨å†Œ] ${user.nickname} (${username})`);
    
    socket.emit('register:success', { 
      user: {
        odp: user.odp,
        username: user.username,
        nickname: user.nickname,
        avatar: user.avatar,
        signature: user.signature
      }
    });
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·æ–°ç”¨æˆ·ä¸Šçº¿
    socket.broadcast.emit('user:online', {
      odp: user.odp,
      nickname: user.nickname,
      avatar: user.avatar,
      signature: user.signature
    });
    
    // å‘é€åœ¨çº¿ç”¨æˆ·åˆ—è¡¨
    sendOnlineUsers(socket, user.odp);
  });

  // ===== ç”¨æˆ·ç™»å½• =====
  socket.on('user:login', (data) => {
    const { username, password } = data;
    
    if (!username || !password) {
      return socket.emit('login:fail', { message: 'è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ' });
    }
    
    // æŸ¥æ‰¾ç”¨æˆ·
    const user = Object.values(registeredUsers).find(u => u.username === username);
    if (!user) {
      return socket.emit('login:fail', { message: 'ç”¨æˆ·ä¸å­˜åœ¨' });
    }
    
    // éªŒè¯å¯†ç 
    if (user.password !== hashPassword(password)) {
      return socket.emit('login:fail', { message: 'å¯†ç é”™è¯¯' });
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²åœ¨çº¿ï¼ˆè¸¢æ‰æ—§è¿æ¥ï¼‰
    if (userSockets.has(user.odp)) {
      const oldSocketId = userSockets.get(user.odp);
      const oldSocket = io.sockets.sockets.get(oldSocketId);
      if (oldSocket) {
        oldSocket.emit('force:logout', { message: 'æ‚¨çš„è´¦å·åœ¨å…¶ä»–è®¾å¤‡ç™»å½•' });
        oldSocket.disconnect();
      }
    }
    
    // è®°å½•åœ¨çº¿çŠ¶æ€
    onlineSockets.set(socket.id, user.odp);
    userSockets.set(user.odp, socket.id);
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·æ­¤ç”¨æˆ·ä¸Šçº¿
    socket.broadcast.emit('user:online', {
      odp: user.odp,
      nickname: user.nickname,
      avatar: user.avatar,
      signature: user.signature
    });
    
    console.log(`[ç™»å½•] ${user.nickname} (${username})`);
    
    socket.emit('login:success', { 
      user: {
        odp: user.odp,
        username: user.username,
        nickname: user.nickname,
        avatar: user.avatar,
        signature: user.signature
      }
    });
    
    // å‘é€åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆæ’é™¤è‡ªå·±ï¼‰
    sendOnlineUsers(socket, user.odp);
    
    // å‘é€ç¾¤èŠåˆ—è¡¨
    sendUserRooms(socket, user.odp);
  });

  // ===== è·å–åœ¨çº¿ç”¨æˆ· =====
  socket.on('users:getOnline', () => {
    const myodp = onlineSockets.get(socket.id);
    if (myodp) {
      sendOnlineUsers(socket, myodp);
    }
  });

  // ===== å‘é€åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ =====
  function sendOnlineUsers(socket, excludeodp) {
    const onlineList = [];
    userSockets.forEach((socketId, odp) => {
      if (odp !== excludeodp) {
        const user = registeredUsers[odp];
        if (user) {
          onlineList.push({
            odp: user.odp,
            nickname: user.nickname,
            avatar: user.avatar,
            signature: user.signature,
            status: 'online'
          });
        }
      }
    });
    socket.emit('users:list', onlineList);
  }

  // ===== å‘é€ç”¨æˆ·ç¾¤èŠåˆ—è¡¨ =====
  function sendUserRooms(socket, odp) {
    const userRooms = [];
    Object.values(allRooms).forEach(room => {
      if (room.members.includes(odp)) {
        userRooms.push(room);
        socket.join(room.id); // åŠ å…¥Socket.IOæˆ¿é—´
      }
    });
    socket.emit('rooms:list', userRooms);
  }

  // ===== ç§èŠæ¶ˆæ¯ =====
  socket.on('message:private', (data) => {
    const senderId = onlineSockets.get(socket.id);
    if (!senderId) return;
    
    const sender = registeredUsers[senderId];
    if (!sender) return;
    
    // å…¼å®¹ to å’Œ receiverId
    const receiverId = data.to || data.receiverId;
    const { type, content, filename, filesize, duration, replyTo } = data;
    
    if (!receiverId || !content) return;
    
    const message = {
      id: uuidv4(),
      type: type || 'text',
      content,
      filename,
      filesize,
      duration,
      // åŒæ—¶æä¾› from/to å’Œ senderId/receiverId ä»¥å…¼å®¹å‰ç«¯
      from: senderId,
      to: receiverId,
      senderId,
      senderName: sender.nickname,
      senderAvatar: sender.avatar,
      receiverId,
      timestamp: Date.now(),
      status: 'sent',
      replyTo: replyTo || null
    };
    
    // ä¿å­˜æ¶ˆæ¯
    const chatId = getChatId(senderId, receiverId);
    if (!allMessages[chatId]) {
      allMessages[chatId] = [];
    }
    allMessages[chatId].push(message);
    saveJSON(messagesFile, allMessages);
    
    // å‘é€ç»™æ¥æ”¶è€…
    const receiverSocketId = userSockets.get(receiverId);
    if (receiverSocketId) {
      io.to(receiverSocketId).emit('message:private', message);
      message.status = 'delivered';
    }
    
    // å‘é€ç»™å‘é€è€…è‡ªå·±ï¼ˆç¡®ä¿åŒæ–¹éƒ½èƒ½çœ‹åˆ°æ¶ˆæ¯ï¼‰
    socket.emit('message:private', message);
    
    console.log(`[ç§èŠ] ${sender.nickname} -> ${registeredUsers[receiverId]?.nickname || receiverId}: ${type === 'text' ? content.slice(0, 20) : `[${type}]`}`);
  });

  // ===== è·å–æ¶ˆæ¯å†å² (é€šç”¨) =====
  socket.on('messages:get', (data) => {
    const myodp = onlineSockets.get(socket.id);
    if (!myodp) return socket.emit('messages:history', { chatId: data?.targetId, messages: [] });
    
    const { type, targetId } = data;
    
    if (type === 'private') {
      const chatId = getChatId(myodp, targetId);
      const messages = allMessages[chatId] || [];
      socket.emit('messages:history', { chatId, messages: messages.slice(-100) });
    } else if (type === 'room') {
      const messages = allMessages[targetId] || [];
      socket.emit('messages:history', { chatId: targetId, messages: messages.slice(-100) });
    }
  });

  // ===== è·å–èŠå¤©å†å² =====
  socket.on('chat:getHistory', (data) => {
    const myodp = onlineSockets.get(socket.id);
    if (!myodp) return socket.emit('messages:history', { chatId: data?.odp, messages: [] });
    
    const { odp } = data;
    const chatId = getChatId(myodp, odp);
    const messages = allMessages[chatId] || [];
    
    socket.emit('messages:history', { chatId, messages: messages.slice(-100) });
  });

  // ===== åˆ›å»ºç¾¤èŠ =====
  socket.on('room:create', (data) => {
    const creatorId = onlineSockets.get(socket.id);
    if (!creatorId) return socket.emit('room:error', { message: 'æœªç™»å½•' });
    
    const creator = registeredUsers[creatorId];
    if (!creator) return socket.emit('room:error', { message: 'ç”¨æˆ·ä¸å­˜åœ¨' });
    
    const { name, description, members: memberIds } = data;
    
    if (!name || name.trim().length === 0) {
      return socket.emit('room:error', { message: 'ç¾¤åç§°ä¸èƒ½ä¸ºç©º' });
    }
    
    // ç¡®ä¿åˆ›å»ºè€…åœ¨æˆå‘˜åˆ—è¡¨ä¸­
    const members = [creatorId];
    if (memberIds && Array.isArray(memberIds)) {
      memberIds.forEach(id => {
        if (id !== creatorId && registeredUsers[id]) {
          members.push(id);
        }
      });
    }
    
    const roomId = uuidv4();
    const room = {
      id: roomId,
      name: name.trim(),
      description: description || '',
      avatar: null,
      creator: creatorId,
      admins: [creatorId],
      members,
      createdAt: new Date().toISOString()
    };
    
    allRooms[roomId] = room;
    saveJSON(roomsFile, allRooms);
    
    // åˆå§‹åŒ–ç¾¤æ¶ˆæ¯
    allMessages[roomId] = [];
    saveJSON(messagesFile, allMessages);
    
    // é€šçŸ¥æ‰€æœ‰æˆå‘˜
    members.forEach(memberId => {
      const memberSocketId = userSockets.get(memberId);
      if (memberSocketId) {
        const memberSocket = io.sockets.sockets.get(memberSocketId);
        if (memberSocket) {
          memberSocket.join(roomId);
          memberSocket.emit('room:created', room);
        }
      }
    });
    
    console.log(`[ç¾¤èŠ] ${creator.nickname} åˆ›å»ºäº†ç¾¤ "${name}"`);
  });

  // ===== ç¾¤èŠæ¶ˆæ¯ =====
  socket.on('message:room', (data) => {
    const senderId = onlineSockets.get(socket.id);
    if (!senderId) return;
    
    const sender = registeredUsers[senderId];
    if (!sender) return;
    
    const { roomId, type, content, filename, filesize, duration, replyTo } = data;
    
    const room = allRooms[roomId];
    if (!room || !room.members.includes(senderId)) return;
    
    const message = {
      id: uuidv4(),
      type: type || 'text',
      content,
      filename,
      filesize,
      duration,
      senderId,
      senderName: sender.nickname,
      senderAvatar: sender.avatar,
      roomId,
      timestamp: new Date().toISOString(),
      replyTo: replyTo || null
    };
    
    // ä¿å­˜æ¶ˆæ¯
    if (!allMessages[roomId]) {
      allMessages[roomId] = [];
    }
    allMessages[roomId].push(message);
    saveJSON(messagesFile, allMessages);
    
    // å‘é€ç»™ç¾¤å†…æ‰€æœ‰æˆå‘˜
    io.to(roomId).emit('message:room', message);
    
    console.log(`[ç¾¤èŠæ¶ˆæ¯] ${sender.nickname} -> ${room.name}: ${type === 'text' ? content.slice(0, 20) : `[${type}]`}`);
  });

  // ===== è·å–ç¾¤èŠå†å² =====
  socket.on('room:getHistory', (data) => {
    const { roomId } = data;
    const messages = allMessages[roomId] || [];
    socket.emit('messages:history', { chatId: roomId, messages: messages.slice(-100) });
  });

  // ===== åŠ å…¥ç¾¤èŠæˆ¿é—´ =====
  socket.on('room:join', (roomId) => {
    const odp = onlineSockets.get(socket.id);
    if (!odp) return;
    
    const room = allRooms[roomId];
    if (room && room.members.includes(odp)) {
      socket.join(roomId);
    }
  });

  // ===== æ¶ˆæ¯å·²è¯» =====
  socket.on('message:read', (data) => {
    const { chatId, messageIds } = data;
    if (!allMessages[chatId]) return;
    
    messageIds.forEach(msgId => {
      const msg = allMessages[chatId].find(m => m.id === msgId);
      if (msg) {
        msg.status = 'read';
      }
    });
    saveJSON(messagesFile, allMessages);
    
    // é€šçŸ¥å‘é€è€…
    const myodp = onlineSockets.get(socket.id);
    if (chatId.includes('_')) {
      const otherodp = chatId.split('_').find(id => id !== myodp);
      const otherSocketId = userSockets.get(otherodp);
      if (otherSocketId) {
        io.to(otherSocketId).emit('message:readReceipt', { chatId, messageIds });
      }
    }
  });

  // ===== æ­£åœ¨è¾“å…¥ =====
  socket.on('typing:start', (data) => {
    const senderId = onlineSockets.get(socket.id);
    if (!senderId) return;
    
    const sender = registeredUsers[senderId];
    const { receiverId, roomId } = data;
    
    if (roomId) {
      socket.to(roomId).emit('typing:start', { odp: senderId, nickname: sender?.nickname, roomId });
    } else if (receiverId) {
      const receiverSocketId = userSockets.get(receiverId);
      if (receiverSocketId) {
        io.to(receiverSocketId).emit('typing:start', { odp: senderId, nickname: sender?.nickname });
      }
    }
  });

  socket.on('typing:stop', (data) => {
    const senderId = onlineSockets.get(socket.id);
    if (!senderId) return;
    
    const { receiverId, roomId } = data;
    
    if (roomId) {
      socket.to(roomId).emit('typing:stop', { odp: senderId, roomId });
    } else if (receiverId) {
      const receiverSocketId = userSockets.get(receiverId);
      if (receiverSocketId) {
        io.to(receiverSocketId).emit('typing:stop', { odp: senderId });
      }
    }
  });

  // ===== æ¶ˆæ¯æ’¤å› =====
  socket.on('message:recall', (data) => {
    const senderId = onlineSockets.get(socket.id);
    if (!senderId) return;
    
    const { messageId, chatId, roomId } = data;
    const key = roomId || chatId;
    
    if (!allMessages[key]) return;
    
    const msgIndex = allMessages[key].findIndex(m => m.id === messageId && m.senderId === senderId);
    if (msgIndex === -1) return;
    
    // æ£€æŸ¥æ—¶é—´ï¼ˆ2åˆ†é’Ÿå†…å¯æ’¤å›ï¼‰
    const msg = allMessages[key][msgIndex];
    const timeDiff = Date.now() - new Date(msg.timestamp).getTime();
    if (timeDiff > 2 * 60 * 1000) {
      socket.emit('error', { message: 'è¶…è¿‡2åˆ†é’Ÿçš„æ¶ˆæ¯æ— æ³•æ’¤å›' });
      return;
    }
    
    msg.type = 'recalled';
    msg.content = 'æ¶ˆæ¯å·²æ’¤å›';
    saveJSON(messagesFile, allMessages);
    
    if (roomId) {
      io.to(roomId).emit('message:recalled', { messageId, roomId });
    } else {
      const otherodp = chatId.split('_').find(id => id !== senderId);
      const otherSocketId = userSockets.get(otherodp);
      if (otherSocketId) {
        io.to(otherSocketId).emit('message:recalled', { messageId, chatId });
      }
      socket.emit('message:recalled', { messageId, chatId });
    }
  });

  // ===== æ›´æ–°ç”¨æˆ·èµ„æ–™ =====
  socket.on('user:update', (data) => {
    const odp = onlineSockets.get(socket.id);
    if (!odp) return socket.emit('user:updateFail', { message: 'æœªç™»å½•' });
    
    const user = registeredUsers[odp];
    if (!user) return socket.emit('user:updateFail', { message: 'ç”¨æˆ·ä¸å­˜åœ¨' });
    
    const { nickname, avatar, signature } = data;
    
    if (nickname !== undefined) user.nickname = nickname;
    if (avatar !== undefined) user.avatar = avatar;
    if (signature !== undefined) user.signature = signature;
    
    saveJSON(usersFile, registeredUsers);
    
    // å¹¿æ’­æ›´æ–°
    socket.broadcast.emit('user:updated', {
      odp: user.odp,
      nickname: user.nickname,
      avatar: user.avatar,
      signature: user.signature
    });
    
    socket.emit('user:updateSuccess', { user: {
      odp: user.odp,
      nickname: user.nickname,
      avatar: user.avatar,
      signature: user.signature
    }});
  });

  // ===== ä¿®æ”¹å¯†ç  =====
  socket.on('user:changePassword', (data) => {
    const odp = onlineSockets.get(socket.id);
    if (!odp) return socket.emit('password:error', { message: 'æœªç™»å½•' });
    
    const user = registeredUsers[odp];
    if (!user) return socket.emit('password:error', { message: 'ç”¨æˆ·ä¸å­˜åœ¨' });
    
    const { oldPassword, newPassword } = data;
    
    // éªŒè¯æ—§å¯†ç 
    if (user.password !== hashPassword(oldPassword)) {
      return socket.emit('password:error', { message: 'å½“å‰å¯†ç é”™è¯¯' });
    }
    
    // éªŒè¯æ–°å¯†ç 
    if (!newPassword || newPassword.length < 6) {
      return socket.emit('password:error', { message: 'æ–°å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦' });
    }
    
    if (!/[a-zA-Z]/.test(newPassword) || !/[0-9]/.test(newPassword)) {
      return socket.emit('password:error', { message: 'å¯†ç éœ€è¦åŒ…å«å­—æ¯å’Œæ•°å­—' });
    }
    
    // æ›´æ–°å¯†ç 
    user.password = hashPassword(newPassword);
    saveJSON(usersFile, registeredUsers);
    
    console.log(`[å¯†ç ä¿®æ”¹] ${user.nickname}`);
    socket.emit('password:changed');
  });

  // ===== æ–­å¼€è¿æ¥ =====
  socket.on('disconnect', () => {
    const odp = onlineSockets.get(socket.id);
    if (odp) {
      const user = registeredUsers[odp];
      console.log(`[ç¦»çº¿] ${user?.nickname || odp}`);
      
      onlineSockets.delete(socket.id);
      userSockets.delete(odp);
      
      // é€šçŸ¥å…¶ä»–ç”¨æˆ·
      socket.broadcast.emit('user:offline', { odp });
    }
  });
});

// ===== å¯åŠ¨æœåŠ¡å™¨ =====
server.listen(PORT, '0.0.0.0', () => {
  const localIP = getLocalIP();
  console.log('\n========================================');
  console.log('ğŸš€ èŠå¤©å®¤æœåŠ¡å™¨å·²å¯åŠ¨!');
  console.log('========================================');
  console.log(`ğŸ“ æœ¬æœºè®¿é—®: http://localhost:${PORT}`);
  console.log(`ğŸ“ å±€åŸŸç½‘è®¿é—®: http://${localIP}:${PORT}`);
  console.log('========================================');
  console.log(`ğŸ“ æ•°æ®ç›®å½•: ${dataDir}`);
  console.log(`ğŸ‘¥ å·²æ³¨å†Œç”¨æˆ·: ${Object.keys(registeredUsers).length}`);
  console.log(`ğŸ’¬ ç¾¤èŠæ•°é‡: ${Object.keys(allRooms).length}`);
  console.log('========================================\n');
});
